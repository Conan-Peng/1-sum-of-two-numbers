# 1-sum-of-two-numbers
1. 关于两数之和的题解
2. 使用两层循环，第一层遍历所有元素，第二层遍历第一层给定元素后面的所有元素。

# 在需要取出栈或队列中的元素进行操作时，定义临时变量进行存储的好处
因为是取出节点进行操作，可以定义临时变量存储所取节点，好处在于 
1. 避免频繁调用成员函数浪费时间， 
2. 使代码逻辑更加清晰一目了然， 
3. 避免同时调用多种成员出现调用冲突。

# 画程序流程图
1. 在写程序时有利于：1）快速将一闪而过的思维灵感用自然语言描述出来，而后再将其转换为机器语言较为高效；2）有利于将运行逻辑更清晰，更直观地展现出来（逻辑可视化）。
2. 在读程序时有利于：将原作者的思维逻辑按顺序，循环，判断框图可视化，比没有明显联结关系的代码更易直观理解。

# delete 和 delete [] 的使用区别
1.delete内置类型的数组时，可以混用delete 和 delete []， 因为delete内置类型不需要调用析构函数。
2.delete自定义类型的数组时，只能用 delete[]，如果用delete只会调用第一个元素的析构函数，无法释放每个元素的内存空间。
3.delete单个元素的内存空间时，可以混用delete 和 delete []。

# 内存空间泄露
内存泄漏（Memory Leak）是指程序中己“动态分配”的“堆内存”由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。


# 动态规划的解题步骤：
1.确定可以用动规，也就是最优序列可以由最优子序列表示（存在重叠overlap）
2.开动规数组表示状态
3.列出递推式（前两步都有的话，这一步水到渠成）
4.代码实现
（最难的是第一步）
//动规一定要穷举出所有的状态，不过一些已经计算过的可以不用再重复计算而已。

# 智能指针主要解决三个问题：
1. 忘记释放发生的内存泄露
2. 悬垂指针问题
3. 抛出异常时的内存泄露

# 从四行代码看右值引用
1. 右值引用是C++11新增加的一个重要特性，它主要解决两个问题：1）临时对象非必要的昂贵的拷贝操作；2）在模板函数中如何按照参数的实际类型进行转发。
2. 第一行代码：int i = getVar();这行代码使用getVar()函数产生一个整型值，实际上这行代码生成了两种类型的值，一种是左值i，在表达式结束时依然存在，另一种是getVar()返回的临时值，这种临时值在表达式结束的时候就被销毁了，这个临时值就是右值。左值是具名的，右值是不具名的。一般而言，如果能对表达式取地址，则此表达式为左值，否则为右值。所有的具名变量都是左值，所有的匿名变量都是右值。lamda表达式就是右值。右值的特点就是表达式结束后就被销毁了。
3. 第二行代码：T&& k = getVar();这行代码多了一个“&&”,这就是右值引用。由于右值是匿名变量，所以我们只能通过右值引用来获取右值。根据第二条描述的，一般右值在表达式结束时就被销毁了，为了给右值续命，我们可以使用右值引用，只要右值引用类型的变量没有被销毁，右值临时值就一直存在。//利用右值引用可以延长右值生命周期，避免临时变量的拷贝构造和析构，提高性能。在之前的C++版本中，常量左值引用也可以达到同样的效果。常量左值引用是一个万能的引用类型，它可以接收左值，右值，常量左值，常量右值。而普通的左值引用是不能接收右值的。比如T& k = getVar()就是错误的。//右值引用的另一个特点是右值引用独立于左值和右值，也就是说，右值引用类型的变量既可以是左值，又可以是右值。比如T&& t = 0, t就是右值，int x = 0; T&& t = x, t就是左值。正是由于右值引用既可以是左值，又可以是右值，这都依赖于初始化，我们可以利用这一点做文章，比如移动语义（move）和完美转发（forward）.
4. 第三行代码：T(T&& a): m_val(a.m_val){a.m_val = nullptr;}这里是将右值引用作为构造函数的参数。一般一个带有堆内存的类必须提供一个深拷贝拷贝构造函数，因为默认的拷贝构造函数是浅拷贝，会发生”指针悬垂“问题，也就是堆内存可能会被删除两次。提供深拷贝的拷贝构造函数有时候会造成性能的损失，尤其是临时变量在拷贝完成后就被销毁了，当堆内存很大时，调用拷贝构造函数再调用析构函数会造成性能的浪费。我们可以定义移动构造函数来解决这个问题。实际上第三行代码就是一个移动构造函数。这个函数没有做深拷贝，而是仅仅将指针的所有者转移到了另一个对象。同时将原对象的指针置空。这就解决了“临时变量的深拷贝问题”。移动构造函数的参数是一个右值引用类型。#临时变量的拷贝会自动匹配到这个构造函数，因为这个函数的参数是一个右值引用类型。# 也就是说，对于临时值，我们只需要做浅拷贝就行，无需做深拷贝，这样就解决了临时变量深拷贝造成性能损失的问题。这就是所谓的移动语义。*右值引用的一个重要作用就是支持移动语义。
*移动语义是通过右值引用来匹配临时值的。
*普通的左值引用也可以通过移动语义来优化性能。这个时候就需要用到move函数。move可以将左值转换为右值，从而应用移动语义。
*move是将一个对象的资源转移到另一个对象，只有转移而没有内存的拷贝。这就是move语义。（需要注意的是，move唯一的功能就是将一个左值转换为一个右值引用，对于内置类型如int，char，应用move依然会发生拷贝，因为它们没有对应的移动构造函数。move对含有资源（堆内存或者句柄）的对象更有意义。）
5. 第四行代码：template<typename T> void f(T&& val){foo(forward<T>(val));} 这里是实现完美转发，在保持参数左值或者右值特征的前提下，将参数传递给模板函数内调用的另一个函数。T&& val属于未定引用，forward会按参数的实际类型匹配对应的重载函数，实现完美转发。（完美转发的一个好处是实现移动语义，实际参数类型是左值则匹配到拷贝构造函数，实际类型是右值则匹配到移动构造函数。）



